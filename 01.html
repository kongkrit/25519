<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Web Crypto PKI Demo</title>

  <style>
  
  /* ---------- COLORS --------- */
  :root {
    --bg: #ffffff;
    --fg: #000000;
    --accent: #dddddd;
  }
  body[data-theme="dark"] {
    --bg: #1e1e1e;
    --fg: #e0e0e0;
    --accent: #444444;
  }
  
  /* ---------- ELEMENT SIZES --------- */
  :root {
    --html-fs-min: 14px;
	--html-fs-vw: 1.5vw;
	--html-fs-max: 18px;
	
	--h1-fs: 2rem;
	--h2-fs: 1.5rem;
	--h3-fs: 1.1rem;
	--default-fs: 1rem;
	--default-border-width: 1px;
	--default-padding-top-bottom: 0.5rem;
    --default-padding-left-right: 1rem;
	--default-border-radius: 0.3rem;
	
	--p-gap: 0.5rem;
  }
  
  /* ---------- color controlling elements -------- */
  html { font-size: clamp(var(--html-fs-min), var(--html-fs-vw), var(--html-fs-max)); }

  body { background: var(--bg); color: var(--fg); font-family: sans-serif; }
  textarea, button { background: var(--bg); color: var(--fg); }
  button, textarea { border-color: var(--fg); }
  label { border-color: var(--bg); }
  
  /* ---------- font/size controlling elements ---------- */
  h1 { font-size: var(--h1-fs); }
  h2 { font-size: var(--h2-fs); }
  h3 { font-size: var(--h3-fs); }
  body { font-family: sans-serif; }
  button, textarea, label {
    font-family: monospace;
    border-width: var(--default-border-width);
    border-style: solid;
    font-size: var(--default-fs);
    padding: var(--default-padding-top-bottom) var(--default-padding-left-right);
    border-radius: var(--default-border-radius);
    cursor: pointer;
  }
  textarea {
    flex: 1;
  }
  
  </style>

</head>
<body>
  <h1>Web Crypto PKI Demo</h1>

  <button id="theme">Light / Dark</button>


  <!-- Section 1 — generate keys -->
  <section aria-labelledby="sec1">
    <h2 id="sec1">1) Generate keys</h2>
	<h3>X25519 is for encryption. Ed25519 is for signature</h3>
    <button id="generateX25519">Generate X25519</button>
    <button id="generateEd25519">Generate Ed25519</button>
    <div id="warn-sec1" role="status" aria-live="polite"></div>
    <p>
      <label for="privatekeyX25519">X25519 private key</label><br>
      <textarea id="privatekeyX25519" rows="3" cols="80" spellcheck="false"></textarea>
      <button id="copy" data-for="privatekeyX25519">copy</button>
    </p>
    <p>
      <label for="publickeyX25519">X25519 public key</label><br>
      <textarea id="publickeyX25519" rows="3" cols="80" spellcheck="false"></textarea>
      <button id="copy" data-for="publickeyX25519">copy</button>
    </p>
    <p>
      <label for="privatekeyEd25519">Ed25519 private key</label><br>
      <textarea id="privatekeyEd25519" rows="3" cols="80" spellcheck="false"></textarea>
      <button id="copy" data-for="privatekeyEd25519">copy</button>
    </p>
    <p>
      <label for="publickeyEd25519">Ed25519 public key</label><br>
      <textarea id="publickeyEd25519" rows="3" cols="80" spellcheck="false"></textarea>
      <button id="copy" data-for="publickeyEd25519">copy</button>
    </p>
  </section>

  <br>

  <!-- Section 2 — encrypt and sign message -->
  <section aria-labelledby="sec2">
    <h2 id="sec2">2) Encrypt and sign</h2>
    <p>
      <label for="message">Message</label><br>
      <textarea id="message" rows="3" cols="80">Hello asymmetric encryption</textarea>
      <button id="copy" data-for="message">copy</button>
    </p>
    <p>
      <button id="sign">Sign with Ed25519 private key</button>
      <div id="warn-sign" role="status" aria-live="polite"></div>
    </p>
    <p>
      <label for="signature">Signature (Ed25519)</label><br>
      <textarea id="signature" rows="3" cols="80" spellcheck="false" readonly></textarea>
      <button id="copy" data-for="signature">copy</button>
    </p>
    <p>
      <button id="encrypt">Encrypt with X25519 public key</button>
      <div id="warn-encrypt" role="status" aria-live="polite"></div>
    </p>
    <p>
      <label for="encrypted">Encrypted payload</label><br>
      <textarea id="encrypted" rows="6" cols="80" spellcheck="false" readonly></textarea>
      <button id="copy" data-for="encrypted">copy</button>
    </p>
  </section>

  <br>

  <!-- Section 3 — verify and decrypt -->
  <section aria-labelledby="sec3">
    <h2 id="sec3">3) Verify and decrypt</h2>
    <p>
      <button id="verify">Verify signature</button>
      <span id="valid-message-signature" aria-live="polite"></span>
      <div id="warn-verify" role="status" aria-live="polite"></div>
    </p>
    <p>
      <label for="verified">Verified echo</label><br>
      <textarea id="verified" rows="4" cols="80" spellcheck="false" readonly></textarea>
      <button id="copy" data-for="verified">copy</button>
    </p>
    <p>
      <button id="decrypt">Decrypt</button>
      <div id="warn-decrypt" role="status" aria-live="polite"></div>
    </p>
    <p>
      <label for="decrypted">Decrypted message</label><br>
      <textarea id="decrypted" rows="3" cols="80" spellcheck="false" readonly></textarea>
      <button id="copy" data-for="decrypted">copy</button>
    </p>
  </section>

<script>
/* ===== Utilities (pure) ===== */
const b64u = {
  enc: (buf) => {
    const b = Array.from(new Uint8Array(buf), x => String.fromCharCode(x)).join('');
    return btoa(b).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  },
  dec: (str) => {
    const s = str.replace(/-/g,'+').replace(/_/g,'/');
    const pad = '='.repeat((4 - s.length % 4) % 4);
    const bin = atob(s + pad);
    const out = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
    return out.buffer;
  }
};
const txt = {
  enc: (s) => new TextEncoder().encode(s),
  dec: (b) => new TextDecoder().decode(b)
};
const jsonStringifyCompact = (o) => JSON.stringify(o);

/* Feature check (short) */
function requireSupport() {
  const subtle = crypto?.subtle;
  const ok = !!subtle;
  return { ok, reason: ok ? '' : 'Web Crypto unavailable.' };
}

/* ===== Key generation (pure) ===== */
async function genX25519() {
  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);
  const kp = await crypto.subtle.generateKey({name:'X25519'}, true, ['deriveBits']);
  const pub = await crypto.subtle.exportKey('raw', kp.publicKey);
  const prv = await crypto.subtle.exportKey('pkcs8', kp.privateKey); // private export as PKCS8
  return {
    publicKeyB64u: b64u.enc(pub),
    privateKeyB64u: b64u.enc(prv)
  };
}
async function genEd25519() {
  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);
  const kp = await crypto.subtle.generateKey({name:'Ed25519'}, true, ['sign','verify']);
  const pub = await crypto.subtle.exportKey('raw', kp.publicKey);
  const prv = await crypto.subtle.exportKey('pkcs8', kp.privateKey);
  return {
    publicKeyB64u: b64u.enc(pub),
    privateKeyB64u: b64u.enc(prv)
  };
}

/* ===== Signing (pure) ===== */
async function signEd25519(messageStr, privateKeyPkcs8B64u) {
  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);
  if (!messageStr) throw new Error('message missing.');
  if (!privateKeyPkcs8B64u) throw new Error('Ed25519 private key missing.');
  const pkcs8 = b64u.dec(privateKeyPkcs8B64u);
  const key = await crypto.subtle.importKey('pkcs8', pkcs8, {name:'Ed25519'}, false, ['sign']);
  const sig = await crypto.subtle.sign({name:'Ed25519'}, key, txt.enc(messageStr));
  return b64u.enc(sig);
}

/* ===== Encryption via X25519 + HKDF + AES-GCM (pure) ===== */
async function encryptX25519(publicKeyRawB64u, messageStr) {
  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);
  if (!publicKeyRawB64u) throw new Error('X25519 public key missing.');
  if (!messageStr) throw new Error('message missing.');
  // recipient public key
  const pubRaw = b64u.dec(publicKeyRawB64u);
  const recipientPub = await crypto.subtle.importKey('raw', pubRaw, {name:'X25519'}, false, []);
  // ephemeral key pair
  const eph = await crypto.subtle.generateKey({name:'X25519'}, true, ['deriveBits']);
  const ephPubRaw = await crypto.subtle.exportKey('raw', eph.publicKey);
  // derive shared secret
  const shared = await crypto.subtle.deriveBits({name:'X25519', public: recipientPub}, eph.privateKey, 256);
  // KDF
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const ikm = await crypto.subtle.importKey('raw', shared, 'HKDF', false, ['deriveKey']);
  const aesKey = await crypto.subtle.deriveKey(
    { name:'HKDF', hash:'SHA-256', salt, info: txt.enc('X25519-AES-GCM') },
    ikm,
    { name:'AES-GCM', length:256 },
    false,
    ['encrypt']
  );
  // encrypt
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, aesKey, txt.enc(messageStr));
  // package: versioned, includes eph pub, salt, iv, ct
  return jsonStringifyCompact({
    v: 1,
    kem: 'X25519-HKDF-SHA256',
    aead: 'AES-GCM-256',
    epk: b64u.enc(ephPubRaw),
    salt: b64u.enc(salt.buffer),
    iv: b64u.enc(iv.buffer),
    ct: b64u.enc(ct)
  });
}

/* ===== Verification (pure) ===== */
async function verifyEd25519(messageStr, signatureB64u, publicKeyRawB64u) {
  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);
  if (!messageStr) throw new Error('message missing.');
  if (!signatureB64u) throw new Error('signature missing.');
  if (!publicKeyRawB64u) throw new Error('Ed25519 public key missing.');
  const pubRaw = b64u.dec(publicKeyRawB64u);
  const key = await crypto.subtle.importKey('raw', pubRaw, {name:'Ed25519'}, false, ['verify']);
  const ok = await crypto.subtle.verify({name:'Ed25519'}, key, b64u.dec(signatureB64u), txt.enc(messageStr));
  return !!ok;
}

/* ===== Decryption (pure) ===== */
async function decryptX25519(privateKeyPkcs8B64u, payloadJson) {
  const s = requireSupport(); if (!s.ok) throw new Error(s.reason);
  if (!privateKeyPkcs8B64u) throw new Error('X25519 private key missing.');
  if (!payloadJson) throw new Error('encrypted payload missing.');
  let payload;
  try { payload = JSON.parse(payloadJson); }
  catch { throw new Error('bad payload format.'); }
  const { v, epk, salt, iv, ct, kem, aead } = payload;
  if (v!==1 || kem!=='X25519-HKDF-SHA256' || aead!=='AES-GCM-256') throw new Error('unsupported payload params.');
  const prv = await crypto.subtle.importKey('pkcs8', b64u.dec(privateKeyPkcs8B64u), {name:'X25519'}, false, ['deriveBits']);
  const ephPub = await crypto.subtle.importKey('raw', b64u.dec(epk), {name:'X25519'}, false, []);
  const shared = await crypto.subtle.deriveBits({name:'X25519', public: ephPub}, prv, 256);
  const ikm = await crypto.subtle.importKey('raw', shared, 'HKDF', false, ['deriveKey']);
  const aesKey = await crypto.subtle.deriveKey(
    { name:'HKDF', hash:'SHA-256', salt: new Uint8Array(b64u.dec(salt)), info: txt.enc('X25519-AES-GCM') },
    ikm,
    { name:'AES-GCM', length:256 },
    false,
    ['decrypt']
  );
  const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv: new Uint8Array(b64u.dec(iv))}, aesKey, b64u.dec(ct));
  return txt.dec(pt);
}

/* ===== Minimal DOM wire-up ===== */

document.getElementById('theme').addEventListener('click', () => {
  const b = document.body;
  b.dataset.theme = b.dataset.theme === 'dark' ? '' : 'dark';
});

// start with system preference
const mq = window.matchMedia('(prefers-color-scheme: dark)');
document.body.dataset.theme = mq.matches ? 'dark' : '';
// auto-update if system theme changes
mq.addEventListener('change', e => {
  document.body.dataset.theme = e.matches ? 'dark' : '';
});

function warn(el, msg) { el.textContent = msg || ''; }
function setVal(id, v) { document.getElementById(id).value = v; }

document.getElementById('generateX25519').addEventListener('click', async () => {
  const w = document.getElementById('warn-sec1'); warn(w,'');
  try {
    const k = await genX25519();
    // Exported separately to avoid leakage. Public contains no private data.
    setVal('privatekeyX25519', k.privateKeyB64u);
    setVal('publickeyX25519',  k.publicKeyB64u);
    warn(w,'ok');
  } catch(e){ warn(w, e.message); }
});

document.getElementById('generateEd25519').addEventListener('click', async () => {
  const w = document.getElementById('warn-sec1'); warn(w,'');
  try {
    const k = await genEd25519();
    setVal('privatekeyEd25519', k.privateKeyB64u);
    setVal('publickeyEd25519',  k.publicKeyB64u);
    warn(w,'ok');
  } catch(e){ warn(w, e.message); }
});

document.getElementById('sign').addEventListener('click', async () => {
  const w = document.getElementById('warn-sign'); warn(w,'');
  try {
    const sig = await signEd25519(
      document.getElementById('message').value,
      document.getElementById('privatekeyEd25519').value.trim()
    );
    setVal('signature', sig);
    warn(w, 'ok');
  } catch(e){ warn(w, e.message); }
});

document.getElementById('encrypt').addEventListener('click', async () => {
  const w = document.getElementById('warn-encrypt'); warn(w,'');
  try {
    const enc = await encryptX25519(
      document.getElementById('publickeyX25519').value.trim(),
      document.getElementById('message').value
    );
    setVal('encrypted', enc);
    warn(w, 'ok');
  } catch(e){ warn(w, e.message); }
});

document.getElementById('verify').addEventListener('click', async () => {
  const w = document.getElementById('warn-verify'); warn(w,'');
  const msg = document.getElementById('message').value;
  const sig = document.getElementById('signature').value.trim();
  const pub = document.getElementById('publickeyEd25519').value.trim();
  try {
    const ok = await verifyEd25519(msg, sig, pub);
    document.getElementById('valid-message-signature').textContent = ok ? 'valid' : 'invalid';
    setVal('verified', jsonStringifyCompact({message: msg, signature: sig}));
    warn(w, 'ok');
  } catch(e){ warn(w, e.message); }
});

document.getElementById('decrypt').addEventListener('click', async () => {
  const w = document.getElementById('warn-decrypt'); warn(w,'');
  try {
    const pt = await decryptX25519(
      document.getElementById('privatekeyX25519').value.trim(),
      document.getElementById('encrypted').value.trim()
    );
    setVal('decrypted', pt);
    warn(w, 'ok');
  } catch(e){ warn(w, e.message); }
});

/* Copy buttons: every textarea has a sibling button#copy. Multiple same-IDs handled by querySelectorAll. */
document.querySelectorAll('button#copy').forEach(btn=>{
  btn.addEventListener('click', async () => {
    const id = btn.getAttribute('data-for');
    const ta = document.getElementById(id);
    if (!ta) return;
    try { await navigator.clipboard.writeText(ta.value); } catch {}
  });
});
</script>
</body>
</html>
